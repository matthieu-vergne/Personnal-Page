<!DOCTYPE html>
<html lang="en">
<head>
	<title>Blog Page</title>
	<meta charset="utf-8">
	<link href="../style.css" rel="stylesheet" type="text/css" />
	<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			TeX: {
				extensions: ["color.js"],
				equationNumbers: { autoNumber: "AMS" },
			}
		});
	</script>
	<script language="JavaScript" type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-core.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/plugins/autoloader/prism-autoloader.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/plugins/keep-markup/prism-keep-markup.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
	<script language="JavaScript" type="text/javascript" src="../scripts.js"></script>
	<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
</head>
<body id="blog">
<h1>When to Factor some Code?</h1>

<p>
<!-- TODO Lack of factoring -->
</p>
<p>
<!-- TODO Excess of factoring -->
</p>
<div class="warning">TODO Look also: https://itexpert.fr/blog/bonne-duplication-de-code/</div>
<div class="warning">TODO Look also: https://fr.linkedin.com/pulse/factorisation-et-review-du-code-en-solo-ou-%C3%A9quipe-eric-venturino</div>
<div class="warning">TODO Look also: https://essential-dev-skills.com/general/doit-on-abstraire-son-code</div>
<div class="warning">TODO Look also: https://fr.quora.com/Est-ce-une-bonne-id%C3%A9e-de-factoriser-des-choses-en-programmant</div>
<div class="warning">TODO Look also: https://forum.alsacreations.com/topic-5-88046-1-Factorisation-dun-code.html</div>

<h2>Questions</h2>

<p>
In this article, we address the fundamentals of code factoring.
More particularly, we will try to answer all of these fundamental questions:
</p>
<ol>
	<li><em>Why</em> code should be factored?</li>
	<li><em>When</em> code should be factored?</li>
	<li><em>What</em> code should be factored?</li>
	<li><em>Where</em> code should be factored?</li>
	<li><em>How</em> code should be factored?</li>
</ol>

<h2>Solution</h2>

<p>
Despite the fundamental aspect of the questions we want to answer, let's be practical.
There is no point to draw a beautiful theory that would fail to be applicable to our everyday coding.
A theory is good because it applies well to practice ion a systematic manner.
So let's bind these questions to concrete cases that we can face, and let's see how the answers of our questions emerge from them.
</p>

<h3>Avoid the Trap</h3>

<p>
It is not because the devil is in the details that we should immediately sacrifice our brain to it, though.
So let's start with a simple trap:
</p>
<pre><code>
double[] transform(double[] in, double a) {
	double[] out = new double[2];

	out[0] = in[0] + 0.5 * a;
	out[1] = in[1] + 0.5 * a;

	return out;
}
</code></pre>
<p>
Just in case you are looking for the trap, yes the <code>in</code> argument is confirmed to have exactly 2 elements.
But don't beat yourself up if you thought you had it, we all do mistakes.
</p>
<p>
Do you see some reasons to factor this code?
If yes, how would you factor it?
Think about it for a moment before to continue the reading.
</p>
<p>
Do you have your answer?
There is several ways to deal with such a case, but here is a common one:
</p>
<pre><code>
double[] transform(double[] in, double a) {
	double[] out = new double[2];

	out[0] = transformOne(in[0], a);
	out[1] = transformOne(in[1], a);

	return out;
}

double transformOne(double x, double a) {
	return x + 0.5 * a;
}
</code></pre>
<p>
Does your answer look like this?
If you didn't factor as much, like the product but not the sum, don't beat yourself up, because again we all do mistakes.
If you factored it to the same extent, welcome in my trap!
Indeed, this code is buggy, and this factoring just made the bug even harder to fix now.
What do you mean, you couldn't know? I told you from the start: <em>we all do mistakes!</em>
Don't expect some random code found on the internet to be correct just because someone wrote it!
</p>
<p>
But really the motivation does not matter.
It might be a buggy code, like <code>in</code> being a (min, max) pair that we want to increase the range by a given amount <code>a</code> (evenly distributed), but the code actually translates the range instead of increasing it.
It might be a poorly defined requirement, like <code>in</code> representing the volumes of 2 different liquids, and <code>a</code> the amount of overall liquid to add, but the 50/50 distribution comes from having no requirement and it might become 40/60 when it will be clarified.
In both cases the factoring just enforces the common code, and fixing the bug or clarifying the requirement would lead to revert the factoring, thus losing time factoring <em>and</em> reverting it.
</p>
<p>
Here is the mistake: to rely solely on the code similarity to infer what should be factored.
It is good to aim for <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">not repeating yourself</a>, but code similarity is <em>never</em> a decision criteria to tell whether some code should be factored.
It is a good <em>hint</em> that there might be something to factor, but it never goes beyond that.
A motivated factoring comes from two pieces of code sharing the same <em>goal</em>, and thus being computed the same way.
But the goal of the code is not directly expressed in the code itself: it is in the meaning behind it.
Which gives us the first lesson:
</p>
<blockquote><strong><caption>Lesson 1:</caption>
You can only confirm what should be factored based on the <em>semantics</em> of the code, not its mere <em>syntax</em>.
</strong></blockquote>
<p>
As I mentionned earlier, there is several ways to deal with the case above.
But the only reliable one here is to stop when we ask for reasons to factor this code.
There is no way to find one because we miss information to understand the goal of the code.
</p>
<p>
Actually, this lack of information can be identified rather easily.
Indeed, the idea is to factor both formulae, so if one changes then the other also changes since they are now the same.
But if we change the first formula, nothing tells us that the second one should change too.
As we saw, the code similarity alone is not enough to confirm that changing one requires to change the other to make it work.
More generally, when you see some code similarity and think about factoring two pieces of code, ask yourself:
</p>
<blockquote><strong>If we change the first piece of code, do we need to change the second one to make it work?</strong></blockquote>
<ul>
	<li>If yes, then the two pieces of code <em>must</em> be factored, so only one change is required when needed.</li>
	<li>If no, then the two pieces of code <em>must</em> remain separate, so both can evolve separately.</li>
	<li>Any other answer should be reduced to "I don't know", meaning that more information is required to answer the question.</li>
</ul>
<p>
Of course the code here was purposefully made to focus on the similarity of the syntax.
But even a professional code can be way worse than that, so focus on the semantics to avoid that trap.
</p>

<h3>Avoid the Trap - Level 2</h3>

<p>
Now that the most common trap is gone, let's be even more subtle.
And what better way to be subtle than to use an explicit terminology representing our domain?
Joke aside, let's name our method and variables to make everything clear:
</p>
<pre><code>
double[] increaseRange(double[] minMax, double increaseRatio) {
	double[] increasedMinMax = new double[2];

	increasedMinMax[0] = minMax[0] + (minMax[0] - minMax[1]) * increaseRatio;
	increasedMinMax[1] = minMax[1] + (minMax[1] - minMax[0]) * increaseRatio;

	return increasedMinMax;
}
</code></pre>
<p>
Like the previous example, here we also want to increase the range of the (min, max) pair.
The difference is that instead of providing an absolute amount, we provide a relative one through the <code>increaseRatio</code> parameter, like increase it by 20%.
The computation is correct, so let's see what should be factored and why.
Again, please try to come up with your own solution.
</p>
<p>
Do you have it?
Again, we might use several ways, but here is one which is prone to occur:
</p>
<pre><code>
double[] increaseRange(double[] minMax, double increaseRatio) {
	double[] increasedMinMax = new double[2];

	increasedMinMax[0] = compute(minMax[0], minMax[1], increaseRatio);
	increasedMinMax[1] = compute(minMax[1], minMax[0], increaseRatio);

	return increasedMinMax;
}

double compute(double a, double b, double increaseRatio) {
	return a + (a - b) * increaseRatio;
}
</code></pre>
<p>
Doesn't this factoring look pretty smart?
We factor the whole formulae at once, reversing the arguments to cover both the min and max cases.
If you factored it to the same extent and are proud of thinking about the arguments reversal, welcome in my second trap!
</p>
<p>
Do you remember when we were speaking about goals and meaning?
Could you describe me the goal or meaning of <code>compute</code>?
What do <code>a</code> and <code>b</code> represent?
Can you make any sense of them?
What about the colleagues who, once you will be gone, will look at that same code they are not familiar with?
Could you name <code>compute</code> differently to make its purpose clearer?
</p>
<p>
Here is the mistake: to rely solely on the code similarity to infer how it should be factored.
Does it sound familiar?
In the previous section, we identified <em>what</em> should be factored based on the code similarity.
Here, we decide <em>how</em> to factor it based on the code similarity: we just put all the similar stuff together.
As a big fan of code factoring, I did that a lot of times and... Oh, boy! It was not worth it.
Again, code similarity is <em>never</em> a decision criteria to tell <em>how</em> some code should be factored.
It is again a good <em>hint</em>, but that's it.
Which gives us the second lesson:
</p>
<blockquote><strong><caption>Lesson 2:</caption>
You can only confirm how to factor based on the <em>semantics</em> of the code, not its mere <em>syntax</em>.
</strong></blockquote>
<p>
Like before, this lesson is driven by a core question.
But although the lesson is almost identical to the previous one, the question to ask is fundamentally different.
After all, we focus here on the <em>how</em>, not on the <em>what</em>.
Furthermore, if we are here now, it is because we already asked ourselves the previous question.
So we already know that if we change one piece of code, we must change the other piece of code for it to work.
Which means that we already have a potential change in mind.
The next question is then:
</p>
<blockquote><strong>What concept of the domain does this change applies to?</strong></blockquote>
<p>
Now it is not a mere "yes/no" answer.
We touch here to the proper understanding of the code, how it should be <em>conceptually</em> designed.
Conceptual Design is a whole branch of Information Science, too broad to address it here (and too large for what we actually need here).
But the key point is that it focuses on representing the concepts of the domain and their relationships.
More precisely, it is conceptual design with a programming (so at least to some extent a formal) language.
In this case, we can further concentrate on the ontological aspect, with an <a href="https://en.wikipedia.org/wiki/Ontology_(information_science)">ontology</a> being a set of formalized concepts and relationships shared within a group (e.g. team, company, community of experts).
</p>
<p>
Briefly, if you can put a name on the change you have in mind, and this name comes from the ontology of your domain, then you have identified a piece of code to factor.
</p>

<h3>Let's Practice</h3>

<p>
Let's go back to the initial code:
</p>
<pre><code>
double[] increaseRange(double[] minMax, double increaseRatio) {
	double[] increasedMinMax = new double[2];

	increasedMinMax[0] = minMax[0] + (minMax[0] - minMax[1]) * increaseRatio;
	increasedMinMax[1] = minMax[1] + (minMax[1] - minMax[0]) * increaseRatio;

	return increasedMinMax;
}
</code></pre>
<p>
As it explicitly shows, the goal is to increase the range of our (min, max) pair.
Which begs the question: where is the range we are supposed to increase?
If it is such a central concept to this method, where does it appear?
But a range is defined from the difference between the min and max, two elements that we are supposed not only to use, but also to compute.
Which begs again the question: where are the core concepts of min and max?
</p>
<p>
All these notions of min, max, range, etc. are concepts pertaining to the domain of knowledge that this method builds on.
You may give a specific name to this domain, like mathematics, statistics, or whatever-this-article-wants-to-speak-about, but the key point is to identify its relevant concepts and relationships.
By applying them in our code, we build its ontology: the set of formalized concepts and relationships that gives a meaning to our code, a meaning that can be shared with the other people working on it.
</p>
<p>
Once the ontology is identified, we can start looking for its concepts in our code to make them appear.
Starting with the min and max, they are values taken from the <code>minMax</code> array.
So let's do our first valid factoring here:
</p>
<pre><code>
double[] increaseRange(double[] minMax, double increaseRatio) {
	double[] increasedMinMax = new double[2];

	double min = minMax[0];
	double max = minMax[1];
	increasedMinMax[0] = min + (min - max) * increaseRatio;
	increasedMinMax[1] = max + (max - min) * increaseRatio;

	return increasedMinMax;
}
</code></pre>
<p>
This factoring of the min and max concepts allow us to reduce the array retrievals: instead of retrieving the min (or max) 3 times, we only retrieve it once.
But pay attention!
The purpose is not performance: with a quick array retrieval we gain close to nothing by factoring it, as it would be for a long call to some remote storage.
It is all about the <em>meaning</em> behind the code: the min value is a single value, the same for the 3 times we use it.
All we need is to instantiate it once for all, which can be done by retrieving it from <code>minMax[0]</code>.
Once we have it, we can use the same min value everywhere (same for max).
</p>
<p>
What about the range then?
Same thing: the range should be the same for computing the new min and new max.
Since it is the difference between the min and max, we first need to rewrite the code to make it properly appear in both.
To do so, we can replace <code>(min-max)</code> by <code>-(max-min)</code>.
It allows us to factor the range concept in this way:
</p>
<pre><code>
double[] increaseRange(double[] minMax, double increaseRatio) {
	double[] increasedMinMax = new double[2];

	double min = minMax[0];
	double max = minMax[1];
	double range = max - min;
	increasedMinMax[0] = min - range * increaseRatio;
	increasedMinMax[1] = max + range * increaseRatio;

	return increasedMinMax;
}
</code></pre>
<p>
Now again, code similarity is not the decision criteria, but it is a good hint that there is something to factor.
Having twice <code>range * increaseRatio</code> begs the question: does it represent something in our domain?
Yes, it represents the change of range, the absolute amount to remove (or add) to the new min (or max).
This is again a single value, not something that is supposed to change between the new min and the new max.
So let's factor it too:
</p>
<pre><code>
double[] increaseRange(double[] minMax, double increaseRatio) {
	double[] increasedMinMax = new double[2];

	double min = minMax[0];
	double max = minMax[1];
	double range = max - min;
	double rangeChange = range * increaseRatio;
	increasedMinMax[0] = min - rangeChange;
	increasedMinMax[1] = max + rangeChange;

	return increasedMinMax;
}
</code></pre>
<p>
Do you remember when we were speaking about goals and meaning?
Is the goal or meaning of each variable clear?
Can you make sense of all the code?
What about the colleagues who, once you will be gone, will look at that same code they are not familiar with?
Surely it should be easier to deal with that code now because, in the worst case, these colleagues can simply read some descriptions of the relevant domain.
They can then see how it properly shows in your code, providing it a clear meaning.
</p>
<p>
But hey, wait a minute.
Factorization is about bringing common stuff together.
So how come we passed from a method with 2 lines of computation to one with 6 lines of computation?
And that is our third lesson:
</p>
<blockquote><strong><caption>Lesson 3:</caption>
Factoring the code is not about reducing its size, but reducing its maintenance effort.
</strong></blockquote>
<p>
Actually, factoring the code means introducing a concept in the code to abstract the factored instructions, like we introduced the min, max, and range concepts.
If it is a "complex concept", like a whole sequence of instructions, factoring it introduces a new common method (small code increase), but also replaces the redundant instructions by a simple method call (big code reduction).
If it is a "simple concept", like the ones here which represent a single instruction each, factoring it introduces the concept declaration (small code increase), but also replaces each single instruction by its concept (small code reduction at best, small code increase at worst).
Repeat the addition of plenty of simple concepts, and the code globally increases, like in our example.
The maintenance effort, however, decreases in both simple and complex cases because, if a change occurs, it should only be applied to the corresponding concept to have the expected effect everywhere it is relevant.
</p>
<p>
After focusing on <em>what</em> and <em>how</em>, this lesson covers <em>why</em> we should factor the code, meaning we aim to answer the following question:
</p>
<blockquote><strong>What improvements this change bring?</strong></blockquote>
<p>
While the first question was simple and the second more complex, this one is completely trivial.
The answer is always the same: we factor the code to improve its maintainability.
Factoring reduces any change to one single place, making the change quicker to apply but also more obvious to target.
Indeed, if a change applies to a specific concept, then we only need to find the (single) place in the code where this concept is represented.
</p>

<h3>Factoring Storages</h3>

<p>
In this article, I illustrate traps by factoring some code into a separate method, and properly factor it with local variables.
But don't get me wrong, factoring code into a dedicated method is totally valid.
However, it covers a different purpose than the variable.
Actually, it goes way beyond choosing between a variable or a method: it is a matter of <em>information</em> to factor and its <em>scope</em>.
</p>

<h4>Information</h4>

<p>
There are two kinds of information that can be factored: <em>data</em> and <em>computation</em>.
Data is a mere value (number, string, object, etc.), either expressed as a literal or stored in a variable or field.
In our <code>increaseRange</code> example, we only factor various pieces of data into dedicated variables.
Computation is a sequence of instructions to execute (with parameters or not), typically a method or a piece of it.
<code>increaseRange</code> itself can be considered as such, and having its instructions replicated in the code could be the reason why we created <code>increaseRange</code> in the first place.
</p>
<p>
These two kinds of information can be further refined into two variants: <em>fixed</em> and <em>dynamic</em>.
A fixed information is established once for all, while a dynamic information might evolve between uses, usually by relying on a mutable state to infer the variable part.
The dynamicity is not to be mixed with the parameterization, though.
While parameters are what we feed to a method, so we control them, the state might evolve through other means we are not in control with.
</p>
<p>
Data is stored into a variable or field, and whether it is fixed or dynamic tells whether it can be <code>final</code> or not.
Computation is stored into a method, and a dynamic one needs to have a state associated to it.
This state can come from the local instance this method is part of, typically a field, or from another class, like a constant, or be factored with the method itself into a dedicated object.
Since Java 8, we can also use a lambda, which is basically an object defined like a method but possibly inside another method.
If the lambda relies on mutable elements which are not parts of its parameters, it is a dynamic computation, otherwise a fixed one.
In the end, lambdas are objects and objects are delegated methods, so factoring computation always comes down to calling a method in a way or another.
</p>
<p>
It is worth noting that, although a final variable or field can only store fixed data, fixed data is not limited to a final variable or field.
Indeed, a non-final one can store dynamic data, but also fixed data, we just do not exploit the capacity of the storage to change its value.
<code>final</code> is just an additional constraint, so not having it increases the capabilities (and assigning the data once makes it <a href="https://www.baeldung.com/java-effectively-final">effectively final</a> anyway).
Similarly, an object is nice to keep a state required for dynamic computation, but nothing forbids it to not have one and provide fixed computation.
Even better: data can be returned by a method, so when fixed or dynamic data is required, we may as well use a method, a lambda, or an object.
Of course, it is not because an object can do everything that it should be used all the time.
Each of them has its pros and cons, be it memory cost, time cost, maintainability, and so on.
Pick the one that fit your case the best.
</p>

<h4>Scope</h4>

<p>
The scope of the information represents how far are the places that need it.
If you need the same data twice (or more) into a single method, you can factor it into a local variable.
If you need it in different classes, you need to increase its scope, for example by making it a static field.
Similarly, a local computation can be factored into an instance method, while different classes might rely on a static method instead. 
We can identify a few representative scopes:
</p>
<ol>
	<li>we can factor something out of a set of <em>instructions</em> inside a single method, typically some local storage, whether they are variables storing data or lambda storing computation, although an instance method would work as well for the latter ;</li>
	<li>when we need to factor something from two <em>instance methods</em> of a class, it usually requires an instance storage, be it a field or a method ;</li>
	<li>if the methods to factor are <em>static methods</em>, then obviously the storage becomes static as well ;</li>
	<li>if the content to factor is in different <em>classes</em>, the static storage needs to be shared (non private) ;</li>
	<li>this reasoning can even be pushed further to share information between <em>applications</em>, by storing data in a file, or computation in a library or a remote service.</li>
</ol>
<p>
For the information, we saw that we can sort them by increasing capacity, from the final variable to the object for example.
Each next level of storage can also cover the previous ones, although with some extra cost.
Similarly here, each level of scope has the ability to cover the previous ones.
You could imagine create a service for each and every thing to factor, but that would come with an extreme burden on your code.
Again, it is a matter of choosing the right balance based on your needs.
</p>
<p>
Pay attention that the list above only provides representative cases, though.
If you happen to factor something between a static method and an instance method, the static method will impose the need for a static access.
If you don't want to create a static content, you may instead make it a parameter of the methods, or refactor the static method into an instance method to get the factored content through the constructor.
This list only gives technical choices that can support each case, but they are rarely the only ones and are often chosen based on other criteria as well.
It is then a matter of context and practice.
</p>

<h2>Answers</h2>

<!-- TODO -->

Answer them here by summarizing the lessons and secondary questions that allow to answer in more details.
<ol>
	<li><em>Why</em> should we factor the code?</li>
	<li><em>What</em> should we factor (or not factor)?</li>
	<li><em>How</em> should we factor it?</li>
</ol>

<blockquote><strong><caption>Lesson 3:</caption>
Factoring the code is not about reducing its size, but reducing its maintenance effort.
</strong></blockquote>
<blockquote><strong>What improvements this change bring?</strong></blockquote>
<blockquote><strong><caption>Lesson 1:</caption>
You can only confirm what should be factored based on the <em>semantics</em> of the code, not its mere <em>syntax</em>.
</strong></blockquote>
<blockquote><strong>If we change the first piece of code, do we need to change the second one to make it work?</strong></blockquote>
<blockquote><strong><caption>Lesson 2:</caption>
You can only confirm how to factor based on the <em>semantics</em> of the code, not its mere <em>syntax</em>.
</strong></blockquote>
<blockquote><strong>What concept of the domain does this change applies to?</strong></blockquote>

<p>
Here is an overview of storages to use based on the <em>information</em> to factor and its <em>scope</em>:
</p>
<table>
	<thead>
		<tr>
			<th scope="col">
				<!--
				RECIPE FOR DIAGONAL HEADER
				Make it a square div by giving same height than width, then center vertically based on that (+50% from top -50% from content) then rotate 45°, then translate to the corner knowing that (1) it is inside a square so diagonal is 41.42% larger than side, and (2) it is already horizontally centered so half of it is needed to translate.
				-->
				<div style="position: relative ; width: 100% ; padding-bottom: 100%">
					<span style="text-transform: uppercase ; text-align: center ; position: absolute ; left: 0 ; right: 0 ; top: 50% ; transform: translate(0, -50%) rotate(45deg) translate(20.71%, 0)">Info<hr/>Scope</span>
				</div>
			</th>
			<th scope="col">Fixed<br/>Data</th>
			<th scope="col">Dynamic<br/>Data</th>
			<th scope="col">Fixed<br/>Computation</th>
			<th scope="col">Dynamic<br/>Computation</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th scope="row">Instructions<br/>in a Method</th>
			<td>Local final variable</td>
			<td>Local variable</td>
			<td>Local lambda<br/>Instance method</td>
			<td>Local lambda<br/>Local object</td>
		</tr>
		<tr>
			<th scope="row">Instance Methods<br/>in a Class</th>
			<td>Instance final field</td>
			<td>Instance field</td>
			<td>Instance lambda<br/>Instance method</td>
			<td>Instance lambda<br/>Instance object</td>
		</tr>
		<tr>
			<th scope="row">Static Methods<br/>in a Class</th>
			<td>Private static final field</td>
			<td>Private static field</td>
			<td>Private static lambda<br/>Private static method</td>
			<td>Private static lambda<br/>Private static object</td>
		</tr>
		<tr>
			<th scope="row">Classes in<br/>an Application</th>
			<td>Shared<sup class="infoMark" onclick="toggle('shared_desc')"></sup> static final field</td>
			<td>Shared static field</td>
			<td>Shared static lambda<br/>Shared static method</td>
			<td>Shared static lambda<br/>Shared static object</td>
		</tr>
		<tr id="shared_desc"><script>toggle('shared_desc');</script>
			<th scope="row"></th>
			<td colspan=4 style="text-align: left">
				Sharing requires different keywords depending on the classes:
				<ul>
					<li><code>protected</code> for sharing with a child class</li>
					<li>No keyword (default) for sharing with a class in the same package</li>
					<li><code>public</code> for sharing with a class in another package</li>
				</ul>
			</td>
		</tr>
		<tr>
			<th scope="row">Applications<br/>or Services</th>
			<td>Fixed storage<br/>(env, property, file)</td>
			<td>Dynamic storage<br/>(property, file, database)</td>
			<td>Library</td>
			<td>Service</td>
		</tr>
	</tbody>
</table>
<p>
Remember that, for each scope, any storage can as well be replaced by the one on its right.
Similarly, for each kind of information, any storage can as well be replaced by the one below it.
It makes the service the most powerful tool to use for factoring information, but don't use this reason to blindly transform everything into services.
Local variables are still a good way to go with local stuff, just in case it was not that obvious.
Moreover, don't forget that these are only representative cases, and there is more to it than this small table.
Again, choose the storage that fits your needs.
</p>


<!-- Auto formatting of code tags as Java code -->
<script language="Javascript" type="text/javascript">
	for(var tags = document.getElementsByTagName('code'), i = tags.length; i--;) {
		tags[i].className += " prettyprint language-java";
	}
</script>

<!--
<h2 id="links">Related Posts</h2>

TODO
-->

<h2 id="bibliography">Bibliography</h2>

<ul>
<li id="OracleTutorial">
	<cite>Lesson: Generics (Updated)</cite>,
	in <cite>The Java™ Tutorials > Learning the Java Language</cite>,
	accessed <time datetime="2017-03-22">March 22, 2017</time>.
	URL: <a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">https://docs.oracle.com/javase/tutorial/java/generics/index.html</a>
</li>
</ul>
</body>
</html>